package repositoryset

import (
	"encoding/json"
	"fmt"
	"log"
	"os"

	"gh_foundations/cmd/gen/common"
	"gh_foundations/internal/pkg/functions"
	githubfoundations "gh_foundations/internal/pkg/types/github_foundations"

	tea "github.com/charmbracelet/bubbletea"
	"github.com/hashicorp/hcl/v2/hclwrite"
	zone "github.com/lrstanley/bubblezone"
	"github.com/spf13/cobra"
	"github.com/tidwall/gjson"
	yaml "gopkg.in/yaml.v2"
)

var terraformerStateFile string

var questions []common.IQuestion = []common.IQuestion{
	common.NewSelectQuestion(
		"Select the visibility of the repository",
		[]string{
			"public",
			"private",
		},
	),
	common.NewTextQuestion(
		"Enter the name of the repository",
		"",
	),
	common.NewTextQuestion(
		"Enter the description for the repository",
		"",
	),
	common.NewTextQuestion(
		"Enter the default branch for the repository",
		"main",
	),
	common.NewListQuestion(
		"Enter the name(s) of any protected branches",
	),
	common.NewKeyValueListQuestion(
		"Enter custom team permissions for the repository",
	),
	common.NewKeyValueListQuestion(
		"Enter custom user permissions for the repository",
	),
	common.NewSelectQuestion(
		"Enable Github Advance Security",
		[]bool{
			true,
			false,
		},
	),
	common.NewSelectQuestion(
		"Enable vulnerability alerts",
		[]bool{
			true,
			false,
		},
	),
	common.NewListQuestion(
		"Add Topics",
	),
	common.NewTextQuestion(
		"Enter the homepage for the repository",
		"",
	),
	common.NewSelectQuestion(
		"Delete head branches on merge",
		[]bool{
			true,
			false,
		},
	),
	common.NewSelectQuestion(
		"Require web commit signoff",
		[]bool{
			true,
			false,
		},
	),
	common.NewSelectQuestion(
		"Enable Dependabot security updates",
		[]bool{
			true,
			false,
		},
	),
	common.NewSelectQuestion(
		"Allow auto merge",
		[]bool{
			true,
			false,
		},
	),
	common.NewCompositeQuestion(
		"Fill out the following to create the repository using a template repository",
		[]common.CompositeQuestionEntry{
			{
				Key: "Owner",
				Question: common.NewTextQuestion(
					"Enter the owner of the template repository",
					"",
				),
			},
			{
				Key: "Repository",
				Question: common.NewTextQuestion(
					"Enter the name of the template repository",
					"",
				),
			}, {
				Key: "IncludeAllBranches",
				Question: common.NewSelectQuestion(
					"Include all branches from template repository",
					[]bool{
						true,
						false,
					},
				),
			},
		},
	),
	common.NewTextQuestion(
		"Enter the name of a license template",
		"",
	),
}

var GenRepositorySetCmd = &cobra.Command{
	Use:   "repository_set",
	Short: "Generates an hcl file that contains a repository set input. Can be run interactively or with a terraformer file input",
	Long:  `Generates an hcl file that contains a repository set input. Can be run interactively or with a terraformer file input using the --terraformer-file flag. If run with a terraformer file it will generate hcl for all repositories in the state file generated by terraformer.`,
	Args: func(cmd *cobra.Command, args []string) error {
		if terraformerStateFile != "" {
			if _, err := os.Stat(terraformerStateFile); err != nil {
				return err
			}
		}
		return nil
	},
	Run: func(cmd *cobra.Command, args []string) {
		zone.NewGlobal()
		repositorySet := new(githubfoundations.RepositorySetInput)
		if terraformerStateFile != "" {
			repositorySet = genFromTerraformerFile()
		} else {
			m := common.NewModel(questions, func(answers []string) {
				repository := new(githubfoundations.RepositoryInput)
				repository.Name = answers[1]
				repository.Description = answers[2]
				repository.DefaultBranch = answers[3]

				protectedBranches := make([]string, 0)
				err := yaml.Unmarshal([]byte(answers[4]), &protectedBranches)
				if err != nil {
					fmt.Println("Error converting protected branches input to array of strings:", err)
					os.Exit(1)
				}
				repository.ProtectedBranches = protectedBranches

				teamPermissionOverrides := make(map[string]string, 0)
				err = yaml.Unmarshal([]byte(answers[5]), &teamPermissionOverrides)
				if err != nil {
					fmt.Println("Error converting team permissions input to map of strings:", err)
					os.Exit(1)
				}
				repository.RepositoryTeamPermissionsOverride = teamPermissionOverrides

				userPermissions := make(map[string]string, 0)
				err = yaml.Unmarshal([]byte(answers[6]), &userPermissions)
				if err != nil {
					fmt.Println("Error converting user permissions input to map of strings:", err)
					os.Exit(1)
				}
				repository.UserPermissions = userPermissions

				var enableAdvanceSecurity bool
				err = yaml.Unmarshal([]byte(answers[7]), &enableAdvanceSecurity)
				if err != nil {
					fmt.Println("Error converting advance security input to boolean:", err)
					os.Exit(1)
				}
				repository.AdvanceSecurity = enableAdvanceSecurity

				var enableVulnerabilityAlerts bool
				err = yaml.Unmarshal([]byte(answers[8]), &enableVulnerabilityAlerts)
				if err != nil {
					fmt.Println("Error converting vulnerability alerts input to boolean:", err)
					os.Exit(1)
				}
				repository.HasVulnerabilityAlerts = enableVulnerabilityAlerts

				topics := make([]string, 0)
				err = yaml.Unmarshal([]byte(answers[9]), &topics)
				if err != nil {
					fmt.Println("Error converting topics input to array of strings:", err)
					os.Exit(1)
				}
				repository.Topics = topics

				repository.Homepage = answers[10]

				var deleteHeadOnMerge bool
				err = yaml.Unmarshal([]byte(answers[11]), &deleteHeadOnMerge)
				if err != nil {
					fmt.Println("Error converting delete head branch on merge input to boolean:", err)
					os.Exit(1)
				}
				repository.DeleteHeadBranchOnMerge = deleteHeadOnMerge

				var requireWebCommitSignoff bool
				err = yaml.Unmarshal([]byte(answers[12]), &requireWebCommitSignoff)
				if err != nil {
					fmt.Println("Error converting require web commit signoff on merge input to boolean:", err)
					os.Exit(1)
				}
				repository.RequiresWebCommitSignOff = requireWebCommitSignoff

				var enableDependabotSecurityUpdates bool
				err = yaml.Unmarshal([]byte(answers[13]), &enableDependabotSecurityUpdates)
				if err != nil {
					fmt.Println("Error converting dependabot security updates input to boolean:", err)
					os.Exit(1)
				}
				repository.DependabotSecurityUpdates = enableDependabotSecurityUpdates

				var allowAutoMerge bool
				err = yaml.Unmarshal([]byte(answers[14]), &allowAutoMerge)
				if err != nil {
					fmt.Println("Error converting allow auto merge input to boolean:", err)
					os.Exit(1)
				}
				repository.AllowAutoMerge = allowAutoMerge

				var templateRepository githubfoundations.TemplateRepositoryInputs
				err = yaml.Unmarshal([]byte(answers[15]), &templateRepository)
				if err != nil {
					fmt.Printf("%+v", answers[15])
					fmt.Println("Error converting template repository input to object:", err)
					os.Exit(1)
				} else if len(templateRepository.Owner) > 0 && len(templateRepository.Repository) > 0 {
					repository.TemplateRepository = &templateRepository
				}

				repository.LicenseTemplate = answers[16]

				switch answers[0] {
				case "private":
					repositorySet.PrivateRepositories = append(repositorySet.PrivateRepositories, repository)
				case "public":
					repositorySet.PublicRepositories = append(repositorySet.PublicRepositories, repository)
				}
			})
			if _, err := tea.NewProgram(m, tea.WithAltScreen(), tea.WithMouseCellMotion()).Run(); err != nil {
				fmt.Println("Error running program:", err)
				os.Exit(1)
			}
		}

		bytes, _ := json.Marshal(repositorySet)
		fmt.Println(string(bytes))

		file := hclwrite.NewEmptyFile()
		repositorySet.WriteInputsHCL(file)
		output, err := os.Create("repository_set.inputs.hcl")
		if err != nil {
			log.Fatal(err)
		}
		file.WriteTo(output)
	},
}

func init() {
	GenRepositorySetCmd.Flags().StringVarP(&terraformerStateFile, "terraformer-file", "f", "", "Terraformer state file to generate repository_set hcl from")
}

func genFromTerraformerFile() *githubfoundations.RepositorySetInput {
	stateBytes, err := os.ReadFile(terraformerStateFile)
	if err != nil {
		log.Fatalf("Error reading state file %s. %s", terraformerStateFile, err.Error())
	}
	result := gjson.Parse(string(stateBytes))

	list := result.Get("modules.0.resources").Map()
	repositorySets := new(githubfoundations.RepositorySetInput)
	repositoryUserPermissions := make(map[string]map[string]string)
	for resource_id, gjsonResult := range list {
		rType := functions.IdentifyFoundationsResourceType(resource_id)
		rAttributes := gjsonResult.Get("primary.attributes")
		if rType == githubfoundations.Repository {
			repository := functions.MapTerraformerRepositoryToGithubFoundationRepository(rAttributes)
			visibility := rAttributes.Get("visibility").String()
			if visibility == "public" {
				repositorySets.PublicRepositories = append(repositorySets.PublicRepositories, repository)
			} else {
				repositorySets.PrivateRepositories = append(repositorySets.PrivateRepositories, repository)
			}
		} else if rType == githubfoundations.RepositoryCollaborator {
			repositoryName := rAttributes.Get("repository").String()
			permission := rAttributes.Get("permission").String()
			username := rAttributes.Get("username").String()
			userPermission, ok := repositoryUserPermissions[repositoryName]
			if !ok {
				userPermission = make(map[string]string)
			}
			userPermission[username] = permission
			repositoryUserPermissions[repositoryName] = userPermission
		}
	}

	for _, repository := range repositorySets.PrivateRepositories {
		repository.UserPermissions = repositoryUserPermissions[repository.Name]
	}
	for _, repository := range repositorySets.PublicRepositories {
		repository.UserPermissions = repositoryUserPermissions[repository.Name]
	}

	return repositorySets
}
